#include "Arduino.h"
#include "GBusHelpers.h"
#include "GBusWifiMesh.h"
#include <EEPROM.h>
#include <WiFi.h>
#include "driver/adc.h"
#include "Tasker.h"
#include <AES.h>
#include <GCM.h>

#define FWVERSION "1.0"
#define LogLevel ESP_LOG_NONE

MeshApp mesh;
Tasker tasker;

// SAGEM
#define LED_BUILTIN 2
#define RequestDataPin 18
#define DSMRDataSize 511
#define RXD2 16
#define TXD2 17
#define DSMRHeaderSize 18
#define durationReqeust 10 * 1000

// 1:1 der "Encyrption Key" von Energie Burgenland: !!!!ACHTUNG! NICHT DER ECHTE!!!!
uint8_t Key[16] = {0x8D, 0x8E, 0x65, 0x33, 0x37, 0xDA, 0x25, 0xB7, 0x96, 0x63, 0x62, 0xD1, 0xDB, 0x47, 0x18, 0x47};
// "Authentication Key" von Energie wird ab Index=1 bis Index=16 eingetragen: !!!!ACHTUNG! NICHT DER ECHTE!!!!
uint8_t Adata[15] = {0x0A, 0x4F, 0xC8, 0x45, 0x3B, 0x18, 0x96, 0x9F, 0x13, 0xEB, 0x5F, 0x59, 0x65, 0x84, 0x4F};
// uint8_t TestDatagram[] = {0x6A, 0xBF, 0x0A, 0x0E, 0x8D, 0x22, 0x19, 0x55, 0xA1, 0x9D, 0xFB, 0x7F, 0xED, 0x33, 0xC5, 0x18, 0x6D, 0xD6, 0xEA, 0x6C, 0xF3, 0xF7, 0x53, 0x66, 0xD5, 0x61, 0xAF, 0xCE, 0x59, 0xA3, 0x49, 0x55, 0x1C, 0x55, 0xBE, 0x9E, 0xDB, 0xB1, 0xE3, 0x87, 0xF6, 0x63, 0x3D, 0x24, 0xD6, 0x8D, 0x18, 0xA6, 0x14, 0xBE, 0xDC, 0xB9, 0x41, 0x76, 0xFF, 0x72, 0x65, 0x46, 0x19, 0x91, 0x1C, 0x49, 0x87, 0x1E, 0x7C, 0x9C, 0x08, 0x5F, 0xE6, 0xB6, 0xBC, 0xAC, 0x98, 0x4C, 0xF7, 0x72, 0xDE, 0xCD, 0x60, 0x2F, 0x9E, 0x60, 0xD0, 0x59, 0x27, 0xF7, 0xDE, 0x8E, 0xE0, 0x45, 0xBB, 0x8C, 0x4E, 0x32, 0x63, 0x31, 0x22, 0x72, 0x3E, 0x30, 0xF6, 0xBF, 0x18, 0x7E, 0x7E, 0xA0, 0x8B, 0xCE, 0xFF, 0x03, 0x13, 0xEE, 0xE1, 0xE0, 0x40, 0x00, 0x02, 0x00, 0x00, 0x7A, 0xDC, 0xCE, 0xFA, 0xC5, 0x3E, 0xD9, 0xAB, 0x68, 0x55, 0x87, 0xEE, 0x23, 0x94, 0xD9, 0xEE, 0x27, 0xB8, 0x9D, 0x07, 0xF3, 0xE4, 0xFC, 0x1B, 0x36, 0xAD, 0x60, 0xC1, 0xE5, 0x07, 0x44, 0xAA, 0x5E, 0x7D, 0x19, 0x6A, 0xBA, 0xCE, 0x72, 0xA1, 0x50, 0xD5, 0xBC, 0x88, 0xC9, 0x04, 0x01, 0x41, 0x78, 0x97, 0x3F, 0x2A, 0x8E, 0x29, 0x9A, 0x81, 0x41, 0x11, 0xE6, 0xFE, 0x33, 0x85, 0xFE, 0x7D, 0x33, 0x39, 0x2D, 0x67, 0x79, 0x13, 0xDB, 0xEC, 0x2A, 0x63, 0xBD, 0x4D, 0x3A, 0x8A, 0x9E, 0xA9, 0x7A, 0xE6, 0x1D, 0xDA, 0xBC, 0xBD, 0x0A, 0x86, 0xA1, 0x3E, 0x3E, 0x4D, 0xCD, 0x36, 0x30, 0xDF, 0xE1, 0x72, 0xB8, 0xDD, 0xB4, 0x89, 0x66, 0x68, 0x0E, 0xB4, 0x64, 0xCF, 0x26, 0x23, 0x9D, 0x41, 0x0F, 0xD0, 0x4B, 0xD9, 0x09, 0xA6, 0xF0, 0x0D, 0x1E, 0xD6, 0xCD, 0x34, 0x85, 0x7E, 0x7E, 0xA0, 0x30, 0xCE, 0xFF, 0x03, 0x13, 0x86, 0xF8, 0xE0, 0xC0, 0x00, 0x03, 0x00, 0x00, 0x1F, 0x59, 0x2E, 0x1D, 0x57, 0x86, 0x13, 0x02, 0x75, 0x34, 0x32, 0x3F, 0x2B, 0xA1, 0x47, 0x04, 0x52, 0xB8, 0x42, 0x66, 0x2E, 0xBF, 0x53, 0x22, 0xB7, 0xE1, 0x85, 0x72, 0x8E, 0x61, 0xCC, 0x5E};
uint8_t TestDatagram[] =
    //{0xDB, 0x08, 0x53, 0x41, 0x47, 0x35, 0x00, 0x04, 0x72, 0x26, 0x82, 0x01, 0xF2, 0x30, 0x00, 0x00, 0x01, 0x10, 0x31, 0x5B, 0xC4, 0x38, 0x20, 0x79, 0x1D, 0xEB, 0xF5, 0x82, 0x0E, 0x63, 0x5B, 0x3C, 0xBB, 0x2C, 0x5D, 0xC7, 0x01, 0xBD, 0x56, 0x86, 0xC7, 0xA1, 0x51, 0x0C, 0xD0, 0xA7, 0xB3, 0x4C, 0x7D, 0x59, 0xDD, 0x1B, 0xA7, 0x44, 0xF5, 0x0C, 0x8C, 0xF7, 0x6A, 0x54, 0xFF, 0x0A, 0x18, 0x79, 0x45, 0x14, 0x84, 0x8B, 0x6E, 0xFE, 0x6A, 0x5F, 0xC8, 0x81, 0xC0, 0x72, 0x72, 0x28, 0xD2, 0xDF, 0x0D, 0xF3, 0x04, 0x47, 0xD3, 0x36, 0x66, 0x14, 0x2C, 0xC3, 0x38, 0x8E, 0x10, 0x41, 0x3C, 0x56, 0xD7, 0xFC, 0x28, 0x3C, 0x96, 0x8C, 0x48, 0x0C, 0x83, 0xAA, 0x99, 0x30, 0x62, 0xC8, 0x14, 0xA9, 0x55, 0x00, 0xB6, 0x06, 0xAA, 0x70, 0x2F, 0xC7, 0xF5, 0xFC, 0xFC, 0x77, 0x16, 0xB7, 0x1A, 0xB8, 0x71, 0x41, 0xB5, 0x03, 0x93, 0xFC, 0xB7, 0xB2, 0xDC, 0x49, 0xF8, 0x15, 0x0D, 0x1A, 0x92, 0xE4, 0xAC, 0x24, 0xF2, 0x48, 0x53, 0x34, 0xF5, 0x14, 0x7E, 0x02, 0xDD, 0x22, 0x59, 0xAD, 0xC9, 0xD7, 0xB7, 0x9C, 0x7D, 0x66, 0x08, 0xD0, 0xDA, 0xC5, 0xB2, 0x40, 0x84, 0xE6, 0x65, 0x09, 0xC0, 0xBF, 0x62, 0x08, 0xF8, 0x11, 0x8C, 0x63, 0x0F, 0x90, 0x48, 0x35, 0x5A, 0x95, 0xDB, 0x10, 0xA4, 0xEF, 0x2A, 0xC4, 0x02, 0x82, 0xD1, 0x43, 0x4A, 0x73, 0x87, 0xDA, 0x66, 0x74, 0xEE, 0x38, 0x6B, 0x85, 0xE4, 0xA8, 0x16, 0xE3, 0xFF, 0x5F, 0x31, 0x77, 0xBC, 0x9A, 0x47, 0x06, 0x7D, 0xCA, 0x3E, 0xB3, 0xF8, 0x70, 0x66, 0x00, 0x74, 0x44, 0x16, 0x7A, 0x97, 0x79, 0x29, 0xD2, 0x69, 0x28, 0x42, 0xC8, 0x39, 0xB2, 0xA9, 0xDD, 0x9E, 0xF7, 0xE6, 0x6C, 0x05, 0xA8, 0x9D, 0x87, 0xCC, 0x12, 0xA6, 0xDB, 0xD0, 0xCF, 0xEB, 0xE4, 0x84, 0x1B, 0x62, 0x3B, 0xFC, 0xC3, 0x5E, 0x6F, 0xB9, 0xAC, 0x1C, 0xD8, 0x87, 0x0F, 0x4F, 0x05, 0xD5, 0xCB, 0x14, 0x4D, 0x17, 0x99, 0x4B, 0xBA, 0x9A, 0x57, 0xB8, 0xA4, 0x6C, 0x97, 0xD5, 0xF5, 0x54, 0xE0, 0x42, 0x35, 0x3A, 0xB9, 0x71, 0x62, 0x58, 0xB8, 0x2B, 0xF3, 0x52, 0xD8, 0x7C, 0xF1, 0xC8, 0x77, 0xD6, 0x1C, 0xF8, 0x94, 0x83, 0x23, 0x7C, 0x15, 0xB5, 0xFB, 0x5A, 0x60, 0xA9, 0x77, 0x6D, 0x3A, 0xEE, 0x2E, 0x96, 0xA9, 0xC2, 0x2E, 0xE1, 0x1B, 0x89, 0x3B, 0xEE, 0x77, 0x24, 0x2F, 0x21, 0xC4, 0x53, 0xFC, 0xD1, 0x3D, 0xC7, 0x6A, 0x10, 0x50, 0xBB, 0xD1, 0xD3, 0x7B, 0x14, 0xEE, 0x5D, 0xBB, 0xDF, 0xAE, 0xA1, 0x1E, 0xF6, 0x24, 0x6E, 0x93, 0x61, 0xCB, 0x1B, 0xE8, 0xDD, 0x9A, 0x82, 0x9A, 0xD6, 0x3F, 0x81, 0x27, 0xD5, 0xC5, 0xF2, 0xA5, 0x79, 0x6C, 0x38, 0x05, 0x7E, 0x46, 0x7B, 0x5E, 0x99, 0xA7, 0xC4, 0x95, 0x05, 0xE8, 0x1E, 0x2E, 0x28, 0xFC, 0x5A, 0xCA, 0xD1, 0xBF, 0xB9, 0x51, 0x12, 0x2B, 0x52, 0x30, 0x9E, 0x02, 0x51, 0xCA, 0x50, 0x54, 0xB5, 0x8E, 0x5B, 0xCA, 0x42, 0x2A, 0x20, 0x1A, 0x12, 0xD1, 0xEB, 0x2F, 0x5E, 0x65, 0xFA, 0x9E, 0xCA, 0x4E, 0x3F, 0x61, 0xBF, 0x51, 0x49, 0x30, 0x6A, 0xD8, 0xA9, 0xCC, 0xEE, 0x1E, 0x10, 0x37, 0x81, 0xCE, 0xCB, 0xB7, 0xA0, 0xCF, 0x50, 0xB1, 0x35, 0x5D, 0xD5, 0xD8, 0x7F, 0x74, 0x46, 0x5E, 0x15, 0x10, 0x82, 0x1A, 0x85, 0x5A, 0x5D, 0x45, 0x23, 0xD1, 0xBA, 0x16, 0x98, 0xE7, 0x70, 0xE7, 0x9B, 0x92, 0xF4, 0x4E, 0x44, 0x0C, 0xF0, 0xB5, 0x78, 0xD8, 0xF9, 0x79, 0x90, 0x80, 0x4A, 0xED, 0x4A, 0xA5, 0xAA, 0xF3, 0x8B, 0x0F, 0x24, 0x5C, 0xBF, 0x53, 0x58, 0x58, 0xFB, 0x8B, 0xDC};
    {0xDB, 0x08, 0x53, 0x41, 0x47, 0x35, 0x00, 0x04, 0x72, 0x26, 0x82, 0x01, 0xF2, 0x30, 0x00, 0x00, 0x01, 0x10, 0x31, 0x5B, 0xC4, 0x38, 0x20, 0x79, 0x1D, 0xEB, 0xF5, 0x82, 0x0E, 0x63, 0x5B, 0x3C, 0xBB, 0x2C, 0x5D, 0xC7, 0x01, 0xBD, 0x56, 0x86, 0xC7, 0xA1, 0x51, 0x0C, 0xD0, 0xA7, 0xB3, 0x4C, 0x7D, 0x59, 0xDD, 0x1B, 0xA7, 0x44, 0xF5, 0x0C, 0x8C, 0xF7, 0x6A, 0x54, 0xFF, 0x0A, 0x18, 0x79, 0x45, 0x14, 0x84, 0x8B, 0x6E, 0xFE, 0x6A, 0x5F, 0xC8, 0x81, 0xC0, 0x72, 0x72, 0x28, 0xD2, 0xDF, 0x0D, 0xF3, 0x04, 0x47, 0xD3, 0x36, 0x66, 0x14, 0x2C, 0xC3, 0x38, 0x8E, 0x10, 0x41, 0x3C, 0x56, 0xD7, 0xFC, 0x28, 0x3C, 0x96, 0x8C, 0x48, 0x0C, 0x83, 0xAA, 0x99, 0x30, 0x62, 0xC8, 0x14, 0xA9, 0x55, 0x00, 0xB6, 0x06, 0xAA, 0x70, 0x2F, 0xC7, 0xF5, 0xFC, 0xFC, 0x77, 0x16, 0xB7, 0x1A, 0xB8, 0x71, 0x41, 0xB5, 0x03, 0x93, 0xFC, 0xB7, 0xB2, 0xDC, 0x49, 0xF8, 0x15, 0x0D, 0x1A, 0x92, 0xE4, 0xAC, 0x24, 0xF2, 0x48, 0x53, 0x34, 0xF5, 0x14, 0x7E, 0x02, 0xDD, 0x22, 0x59, 0xAD, 0xC9, 0xD7, 0xB7, 0x9C, 0x7D, 0x66, 0x08, 0xD0, 0xDA, 0xC5, 0xB2, 0x40, 0x84, 0xE6, 0x65, 0x09, 0xC0, 0xBF, 0x62, 0x08, 0xF8, 0x11, 0x8C, 0x63, 0x0F, 0x90, 0x48, 0x35, 0x5A, 0x95, 0xDB, 0x10, 0xA4, 0xEF, 0x2A, 0xC4, 0x02, 0x82, 0xD1, 0x43, 0x4A, 0x73, 0x87, 0xDA, 0x66, 0x74, 0xEE, 0x38, 0x6B, 0x85, 0xE4, 0xA8, 0x16, 0xE3, 0xFF, 0x5F, 0x31, 0x77, 0xBC, 0x9A, 0x47, 0x06, 0x7D, 0xCA, 0x3E, 0xB3, 0xF8, 0x70, 0x66, 0x00, 0x74, 0x44, 0x16, 0x7A, 0x97, 0x79, 0x29, 0xD2, 0x69, 0x28, 0x42, 0xC8, 0x39, 0xB2, 0xA9, 0xDD, 0x9E, 0xF7, 0xE6, 0x6C, 0x05, 0xA8, 0x9D, 0x87, 0xCC, 0x12, 0xA6, 0xDB, 0xD0, 0xCF, 0xEB, 0xE4, 0x84, 0x1B, 0x62, 0x3B, 0xFC, 0xC3, 0x5E, 0x6F, 0xB9, 0xAC, 0x1C, 0xD8, 0x87, 0x0F, 0x4F, 0x05, 0xD5, 0xCB, 0x14, 0x4D, 0x17, 0x99, 0x4B, 0xBA, 0x9A, 0x57, 0xB8, 0xA4, 0x6C, 0x97, 0xD5, 0xF5, 0x54, 0xE0, 0x42, 0x35, 0x3A, 0xB9, 0x71, 0x62, 0x58, 0xB8, 0x2B, 0xF3, 0x52, 0xD8, 0x7C, 0xF1, 0xC8, 0x77, 0xD6, 0x1C, 0xF8, 0x94, 0x83, 0x23, 0x7C, 0x15, 0xB5, 0xFB, 0x5A, 0x60, 0xA9, 0x77, 0x6D, 0x3A, 0xEE, 0x2E, 0x96, 0xA9, 0xC2, 0x2E, 0xE1, 0x1B, 0x89, 0x3B, 0xEE, 0x77, 0x24, 0x2F, 0x21, 0xC4, 0x53, 0xFC, 0xD1, 0x3D, 0xC7, 0x6A, 0x10, 0x50, 0xBB, 0xD1, 0xD3, 0x7B, 0x14, 0xEE, 0x5D, 0xBB, 0xDF, 0xAE, 0xA1, 0x1E, 0xF6, 0x24, 0x6E, 0x93, 0x61, 0xCB, 0x1B, 0xE8, 0xDD, 0x9A, 0x82, 0x9A, 0xD6, 0x3F, 0x81, 0x27, 0xD5, 0xC5, 0xF2, 0xA5, 0x79, 0x6C, 0x38, 0x05, 0x7E, 0x46, 0x7B, 0x5E, 0x99, 0xA7, 0xC4, 0x95, 0x05, 0xE8, 0x1E, 0x2E, 0x28, 0xFC, 0x5A, 0xCA, 0xD1, 0xBF, 0xB9, 0x51, 0x12, 0x2B, 0x52, 0x30, 0x9E, 0x02, 0x51, 0xCA, 0x50, 0x54, 0xB5, 0x8E, 0x5B, 0xCA, 0x42, 0x2A, 0x20, 0x1A, 0x12, 0xD1, 0xEB, 0x2F, 0x5E, 0x65, 0xFA, 0x9E, 0xCA, 0x4E, 0x3F, 0x61, 0xBF, 0x51, 0x49, 0x30, 0x6A, 0xD8, 0xA9, 0xCC, 0xEE, 0x1E, 0x10, 0x37, 0x81, 0xCE, 0xCB, 0xB7, 0xA0, 0xCF, 0x50, 0xB1, 0x35, 0x5D, 0xD5, 0xD8, 0x7F, 0x74, 0x46, 0x5E, 0x15, 0x10, 0x82, 0x1A, 0x85, 0x5A, 0x5D, 0x45, 0x23, 0xD1, 0xBA, 0x16, 0x98, 0xE7, 0x70, 0xE7, 0x9B, 0x92, 0xF4, 0x4E, 0x44, 0x0C, 0xF0, 0xB5, 0x78, 0xD8, 0xF9, 0x79, 0x90, 0x80, 0x4A, 0xED, 0x4A, 0xA5, 0xAA, 0xF3, 0x8B, 0x0F, 0x24, 0x5C, 0xBF, 0x53, 0x58, 0x58, 0xFB, 0x8B, 0xDC};

// Prototypes
void DecryptAndExtractValues(uint8_t *fullData, size_t dataSize);
long getValue(char *buffer, int maxlen);
bool ExtractAndSendValue(char *Datagram, String DsmrText, double ScaleValue, String MqttTopicName);

void meshMessage(String msg, String from, int flag);
void SentNodeInfo();
void RequestData();

uint8_t ModulType = 255;

void setup()
{
  Serial.begin(115200);
  pinMode(RequestDataPin, OUTPUT);
  digitalWrite(RequestDataPin, LOW);

  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH);
  delay(100);
  digitalWrite(LED_BUILTIN, LOW);

  Serial2.begin(115200, SERIAL_8N1, RXD2, TXD2, true);

  /**
   * @brief Set the log level for serial port printing.
   */
  esp_log_level_set("*", ESP_LOG_NONE);
  esp_log_level_set(TAG, ESP_LOG_NONE);

  MDF_LOGI("ModuleType: %u", ModulType);

  mesh.onMessage(meshMessage);
  mesh.start(true);

  tasker.setTimeout(RequestData, durationReqeust, 0);
}

void loop()
{
  tasker.loop();

  if (Serial2.available())
  {
    digitalWrite(LED_BUILTIN, HIGH);
    MDF_LOGI("Data received");
    // client.publish("gimpire/EspPowerMeterStromnetzGraz/debug", "Date recevied");
    // client.publish("gimpire/EspPowerMeterStromnetzGraz/datareceived", "ON"); // You can activate the retain flag by setting the third parameter to true

    uint16_t bytesRead = 0;
    byte DsmrDataBuffer[DSMRDataSize];

    bytesRead = Serial2.readBytes(DsmrDataBuffer, DSMRDataSize);

    // client.publish("gimpire/EspPowerMeterStromnetzGraz/debug", String(bytesRead));
    if (bytesRead >= DSMRDataSize)
    {
      // Serial.println("Decrypt Data");
      DecryptAndExtractValues(&DsmrDataBuffer[0], DSMRDataSize);
    }
    digitalWrite(LED_BUILTIN, LOW);
    digitalWrite(RequestDataPin, LOW);
  }
}

void RequestData()
{
  digitalWrite(RequestDataPin, HIGH);
  tasker.setTimeout(RequestData, durationReqeust, 0);
}

void printHex(uint8_t num)
{
  char hexCar[2];

  sprintf(hexCar, "%02X", num);
  //Serial.print(hexCar);
}

void DecryptAndExtractValues(uint8_t *fullData, size_t dataSize)
{
  //Serial.println(dataSize);
  // client.publish("gimpire/EspPowerMeterStromnetzGraz/debug", String((int)dataSize));

  // Check Header
  if (fullData[0] != 0xDB)
    return;
  // Check End Header
  if (fullData[10] != 0x82)
    return;

  // Initialisation Vector zusammenbaun:
  uint8_t iv[12];
  memcpy(&iv[0], &fullData[2], 8);
  memcpy(&iv[8], &fullData[14], 4);

  // Entschlüsseln
  uint8_t plainText[dataSize];
  GCM<AESSmall128> gcmDec;

  gcmDec.setKey(Key, sizeof(Key));
  gcmDec.setIV(iv, sizeof(iv));

  gcmDec.decrypt(plainText, &fullData[DSMRHeaderSize], 491);

  // Serial.println("decrypted:");

  /*for (int i = 0; i < 491; i++)
  {
    // Serial.print(plainText[i]);
    // printHex(plainText[i]);
    Serial.printf("%c", plainText[i]);
  }*/

  // Serial.println("begin decode");
  ExtractAndSendValue((char *)plainText, "1-0:1.8.0", 1000, "ACTIVE_ENERGY_P_TOTAL");
  ExtractAndSendValue((char *)plainText, "1-0:1.8.1", 1000, "ACTIVE_ENERGY_P_T1");
  ExtractAndSendValue((char *)plainText, "1-0:1.8.2", 1000, "ACTIVE_ENERGY_P_T2");
  ExtractAndSendValue((char *)plainText, "1-0:1.7.0", 1, "ACTIVE_POWER_P");

  ExtractAndSendValue((char *)plainText, "1-0:2.8.0", 1000, "ACTIVE_ENERGY_N_TOTAL");
  ExtractAndSendValue((char *)plainText, "1-0:2.8.1", 1000, "ACTIVE_ENERGY_N_T1");
  ExtractAndSendValue((char *)plainText, "1-0:2.8.2", 1000, "ACTIVE_ENERGY_N_T2");
  ExtractAndSendValue((char *)plainText, "1-0:2.7.0", 1, "ACTIVE_POWER_N");
  return;
}

bool ExtractAndSendValue(char *Datagram, String DsmrText, double ScaleValue, String MqttTopicName)
{
  char *result = strstr((char *)Datagram, DsmrText.c_str());
  if (result)
  {
    double ReturnVal = getValue((char *)result, 25) / ScaleValue;
    String Msg = "MQTT " + MqttTopicName + " " + String(ReturnVal, 3);

    mesh.SendMessage(Msg);
    return true;
  }

  return false;
}

bool isNumber(char *res, int len)
{
  for (int i = 0; i < len; i++)
  {
    if (((res[i] < '0') || (res[i] > '9')) && (res[i] != '.' && res[i] != 0))
    {
      return false;
    }
  }
  return true;
}

int FindCharInArrayRev(char array[], char c, int len)
{
  for (int i = len - 1; i >= 0; i--)
  {
    if (array[i] == c)
    {
      return i;
    }
  }
  return -1;
}

long getValue(char *buffer, int maxlen)
{
  int s = FindCharInArrayRev(buffer, '(', maxlen - 2);
  if (s < 8)
    return 0;
  if (s > 32)
    s = 32;
  int l = FindCharInArrayRev(buffer, '*', maxlen - 2) - s - 1;
  if (l < 4)
    return 0;
  if (l > 12)
    return 0;
  char res[16];
  memset(res, 0, sizeof(res));

  if (strncpy(res, buffer + s + 1, l))
  {
    if (isNumber(res, l))
    {
      return (atof(res));
    }
  }
  return 0;
}

void SentNodeInfo()
{
  // uint32_t OwnId = WiFi.macAddress();
  wifi_power_t WifiPower;
  WifiPower = WiFi.getTxPower();

  String Msg = "Name: GBusSmartmeterSagem NodeId:" + String(mesh.GetNodeId()) + " MAC:" + WiFi.macAddress() +
               " Type:" + String(ModulType) + " FW: " + FWVERSION + " WifiPo:" + String(WifiPower);
  // Serial.println("SentNodeInfo");
  // Serial.println(Msg);

  mesh.SendMessage(Msg);
}

void meshMessage(String msg, String from, int flag)
{
  MDF_LOGD("meshMessage payload:%s, from:%u", msg.c_str(), from);

  String Type = getValue(msg, ' ', 0);
  String Number = getValue(msg, ' ', 1);
  String Command = getValue(msg, ' ', 2);
  uint8_t NumberInt = Number.toInt();

  if (Type == "Output")
  {
  }
  else if (msg.startsWith("I'm Root!"))
  {
   MDF_LOGI("Gateway hold alive received");
    // LastCheckForRootNodeMillis = millis();
  }
  else if (Type == "Config")
  {
    Serial.printf("Config\n");
    String ConfigType = getValue(msg, ' ', 1);
    // Config ModulType 2|4|6
    if (ConfigType == "WifiPower")
    {
      String Type = getValue(msg, ' ', 2);
      Serial.printf("WifiPower: %s\n", Type.c_str());
      EEPROM.write(2, (uint8_t)Type.toInt());
      EEPROM.commit();
      ESP.restart();
    }
  }
  else if (Type == "GetNodeInfo")
  {
    SentNodeInfo();
  }
  else if (Type == "Reboot")
  {
    ESP.restart();
  }
}
